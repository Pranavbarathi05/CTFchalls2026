Knowing Is Not Enough ‚Äî Official Writeup
Overview

This challenge is a logic-based web exploitation task.
The objective is not to bypass authentication directly, but to observe how information is revealed through different application states ‚Äî specifically, success and failure paths.

Understanding what the application leaks is more important than brute force.

Step 1: Inspect Client-Side Data

Upon visiting the login page, the application sets a cookie:

auth_hint = 636c6f636b776f726b


This value is hex-encoded.

Decoding it:

636c6f636b776f726b ‚Üí clockwork


‚úÖ This value is the correct password.

Step 2: Trigger the Failure Path

Submitting an incorrect password does not authenticate the user, but it leaks encrypted data:

LQkXGxQMFw0IG1cMHB4dBhsfBg8OFlk=


Important observations:

This is not the flag

It looks like Base64-encoded data

Indicates further processing is required

Step 3: Trigger the Success Path

Submitting the correct password:

clockwork


Authentication succeeds, and the application reveals:

Key: TIME


Still no flag ‚Äî but this is a critical cryptographic hint.

Step 4: Combine the Pieces

From previous steps, we now have:

Component	Source
Encrypted Blob	Failure path
XOR Key	Success path (TIME)
Encoding	Base64

The encrypted blob is:

Base64 encoded

XOR-encrypted using the key TIME

This means:

Base64 decode ‚Üí XOR with TIME ‚Üí Flag

Step 5: Decode the Flag
Example Decode Script
import base64

cipher = "LQkXGxQMFw0IG1cMHB4dBhsfBg8OFlk="
key = "TIME"

data = base64.b64decode(cipher)
flag = ""

for i, b in enumerate(data):
    flag += chr(b ^ ord(key[i % len(key)]))

print(flag)

üèÅ Final Flag
DSCCTF{TIME_IS_THE_KEY}