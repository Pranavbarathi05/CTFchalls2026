import os
import time
import asyncio
import hashlib
import random
from collections import defaultdict, deque
from fastapi import FastAPI, Request
from fastapi.responses import HTMLResponse, JSONResponse
import aiofiles

FLAG = os.getenv("FLAG", "DSCCTF{dev_flag_change_me_2026}")

app = FastAPI()
LOG_FILE = "player_behavior.log"


# ===============================
# ---- DoS Protection State -----
# ===============================

RATE_LIMIT = 12        # requests
WINDOW = 5            # seconds

MAX_CONCURRENT = 25   # global cap


request_log = defaultdict(deque)
active_requests = 0
lock = asyncio.Lock()


# ===============================
# Logging
# ===============================

async def log_event(ip, payload, response_time):
    async with aiofiles.open(LOG_FILE, "a") as f:
        await f.write(f"{time.time()} | {ip} | {payload} | {response_time}\n")


# ===============================
# CPU Burn
# ===============================

def cpu_burn(rounds=20000):
    data = b"quantum_noise"
    for _ in range(rounds):
        data = hashlib.sha256(data).digest()
    return data


# ===============================
# Timing Leak
# ===============================

def quantum_compare(user_input, real_flag):

    cpu_burn(random.randint(400, 1000))

    if len(user_input) > len(real_flag):
        return False

    for i in range(len(user_input)):

        if user_input[i] != real_flag[i]:
            return False

        cpu_burn(18000 + (i * 3000) + random.randint(1000, 1200))

    return user_input == real_flag


# ===============================
# Rate Limiter
# ===============================

def is_rate_limited(ip):

    now = time.time()
    dq = request_log[ip]

    while dq and dq[0] < now - WINDOW:
        dq.popleft()

    if len(dq) >= RATE_LIMIT:
        return True

    dq.append(now)
    return False


# ===============================
# Routes
# ===============================

@app.get("/", response_class=HTMLResponse)
async def home():
    return """
    <html>
        <body style="background:#0e1116;color:#e6edf3;font-family:monospace;text-align:center;margin-top:120px;">
            <h2>Quantum Validation Portal</h2>
            <p>Precision verification takes time.</p>

            <input id='flag' style="padding:10px;width:350px;background:#161b22;border:1px solid #30363d;color:white;"/>
            <br><br>
            <button onclick='send()' style="padding:10px 20px;">Validate</button>

            <script>
            async function send(){
                let val = document.getElementById("flag").value;

                let res = await fetch("/validate", {
                    method:"POST",
                    headers:{"Content-Type":"application/json"},
                    body:JSON.stringify({flag:val})
                });

                let data = await res.json();
                alert(data.msg);
                console.log("Response time: " + data.response_time + "s")
            }
            </script>
        </body>
    </html>
    """


@app.post("/validate")
async def validate(req: Request):

    global active_requests

    ip = req.client.host

    # ---------- Rate limit ----------
    if is_rate_limited(ip):
        return JSONResponse(
            {"msg": "Slow down. Quantum systems dislike noise."},
            status_code=429
        )

    # ---------- Concurrency guard ----------
    async with lock:
        if active_requests >= MAX_CONCURRENT:
            return JSONResponse(
                {"msg": "Server is stabilizing. Try again shortly."},
                status_code=503
            )
        active_requests += 1

    try:

        data = await req.json()
        user_flag = data.get("flag","")

        # ---------- Input guard ----------
        if len(user_flag) > 64:
            return {"msg": "Input rejected."}

        start = time.perf_counter()
        result = quantum_compare(user_flag, FLAG)
        elapsed = round(time.perf_counter() - start, 4)

        asyncio.create_task(log_event(ip, user_flag, elapsed))

        if result:
            return {"msg":"Correct. The waveform collapses."}

        return JSONResponse({
            "msg":"Incorrect.",
            "response_time": elapsed
        })

    finally:
        async with lock:
            active_requests -= 1
