#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define MAX_NOTES 10
#define MAX_SIZE 256

typedef struct {
    char *content;
    size_t size;
    int active;
} Note;

Note notes[MAX_NOTES];
int note_count = 0;
int admin_mode = 0;
int debug_enabled = 0;

void banner() {
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘           MENU PWNER v1.0            â•‘\n");
    printf("â•‘         Tiny Note Manager            â•‘\n");
    printf("â•‘                                      â•‘\n");
    printf("â•‘    A simple way to manage notes      â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
}

void print_menu() {
    printf("\n=== MENU ===\n");
    printf("1. Add note\n");
    printf("2. Edit note\n");
    printf("3. Delete note\n");
    printf("4. View note\n");
    printf("5. List notes\n");
    if (debug_enabled) {
        printf("6. Debug stats\n");
    }
    if (admin_mode) {
        printf("7. Admin panel\n");
    }
    printf("0. Exit\n");
    printf("Choice: ");
    fflush(stdout);
}

int get_int() {
    char buffer[16];
    if (!fgets(buffer, sizeof(buffer), stdin)) {
        return -1;
    }
    return atoi(buffer);
}

void get_string(char *buffer, size_t max_size) {
    if (fgets(buffer, max_size, stdin)) {
        buffer[strcspn(buffer, "\n")] = 0;  // Remove newline
    }
}

void add_note() {
    if (note_count >= MAX_NOTES) {
        printf("[-] Maximum notes reached!\n");
        return;
    }
    
    printf("Note size (max %d): ", MAX_SIZE);
    int size = get_int();
    
    if (size == -1) {
        printf("[-] Input error!\n");
        return;
    }
    
    if (size <= 0 || size > MAX_SIZE) {
        printf("[-] Invalid size!\n");
        return;
    }
    
    int idx = -1;
    for (int i = 0; i < MAX_NOTES; i++) {
        if (!notes[i].active) {
            idx = i;
            break;
        }
    }
    
    if (idx == -1) {
        printf("[-] No free slots!\n");
        return;
    }
    
    notes[idx].content = malloc(size);
    if (!notes[idx].content) {
        printf("[-] Allocation failed!\n");
        return;
    }
    
    notes[idx].size = size;
    notes[idx].active = 1;
    note_count++;
    
    printf("Note content: ");
    get_string(notes[idx].content, size);
    
    printf("[+] Note %d created successfully!\n", idx);
}

void edit_note() {
    printf("Note index: ");
    int idx = get_int();
    
    if (idx == -1) {
        printf("[-] Input error!\n");
        return;
    }
    
    if (idx < 0 || idx >= MAX_NOTES || !notes[idx].active) {
        printf("[-] Invalid note index!\n");
        return;
    }
    
    printf("New content: ");
    get_string(notes[idx].content, notes[idx].size);
    printf("[+] Note %d updated!\n", idx);
}

void delete_note() {
    printf("Note index: ");
    int idx = get_int();
    
    if (idx == -1) {
        printf("[-] Input error!\n");
        return;
    }
    
    if (idx < 0 || idx >= MAX_NOTES || !notes[idx].active) {
        printf("[-] Invalid note index!\n");
        return;
    }
    
    // VULNERABILITY: Use-after-free - pointer not cleared!
    free(notes[idx].content);
    notes[idx].active = 0;
    note_count--;
    
    printf("[+] Note %d deleted!\n", idx);
}

void view_note() {
    printf("Note index: ");
    int idx = get_int();
    
    if (idx == -1) {
        printf("[-] Input error!\n");
        return;
    }
    
    if (idx < 0 || idx >= MAX_NOTES || !notes[idx].active) {
        printf("[-] Invalid note index!\n");
        return;
    }
    
    printf("Note %d: %s\n", idx, notes[idx].content);
}

void list_notes() {
    printf("\n=== NOTES ===\n");
    int found = 0;
    for (int i = 0; i < MAX_NOTES; i++) {
        if (notes[i].active) {
            printf("[%d] Size: %zu, Preview: %.20s%s\n", 
                   i, notes[i].size, notes[i].content,
                   strlen(notes[i].content) > 20 ? "..." : "");
            found = 1;
        }
    }
    if (!found) {
        printf("No notes found.\n");
    }
}

void debug_stats() {
    if (!debug_enabled) return;
    
    printf("\n=== DEBUG STATS ===\n");
    printf("Active notes: %d\n", note_count);
    printf("Admin mode: %s\n", admin_mode ? "ON" : "OFF");
    
    for (int i = 0; i < MAX_NOTES; i++) {
        if (notes[i].active) {
            printf("Note %d: ptr=0x%lx, size=%zu\n", 
                   i, (unsigned long)notes[i].content, notes[i].size);
        }
    }
}

void admin_panel() {
    if (!admin_mode) {
        printf("[-] Access denied! Admin mode required.\n");
        return;
    }
    
    printf("\nðŸŽ‰ ADMIN ACCESS GRANTED! ðŸŽ‰\n");
    printf("Reading flag...\n");
    
    FILE *fp = fopen("flag.txt", "r");
    if (fp) {
        char flag[256];
        if (fgets(flag, sizeof(flag), fp)) {
            printf("Flag: %s", flag);
        }
        fclose(fp);
    } else {
        printf("Flag: DSCCTF{h34p_pwn3r_m4st3r_2026}\n");
    }
}

// Hidden function that can be called via UAF
void trigger_admin() {
    printf("[!] Admin mode activated!\n");
    admin_mode = 1;
}

void setup() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);
    
    // Enable debug mode for easier exploitation
    debug_enabled = 1;
}

int main() {
    setup();
    banner();
    
    printf("Welcome to the Menu Pwner!\n");
    printf("Manage your notes with ease.\n\n");
    
    int choice;
    while (1) {
        print_menu();
        choice = get_int();
        
        if (choice == -1) {
            printf("\n[-] Input error or EOF reached. Exiting.\n");
            break;
        }
        
        switch (choice) {
            case 1:
                add_note();
                break;
            case 2:
                edit_note();
                break;
            case 3:
                delete_note();
                break;
            case 4:
                view_note();
                break;
            case 5:
                list_notes();
                break;
            case 6:
                debug_stats();
                break;
            case 7:
                admin_panel();
                break;
            case 0:
                printf("Goodbye!\n");
                exit(0);
            default:
                printf("[-] Invalid choice!\n");
        }
    }
    
    return 0;
}